=== Iteration 1 - S1 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Payload CMS 3.74.0 and all required packages installed successfully
- Peer dependency warning: @payloadcms/next and @payloadcms/ui require Next.js ^15.4.10 or >=16.1.1, but we have 16.0.10. This may need addressing in future stories if compatibility issues arise.
- Adding "type": "module" to package.json works with existing Next.js setup
- All packages installed: payload, @payloadcms/db-postgres, @payloadcms/next, @payloadcms/richtext-lexical, @payloadcms/ui, graphql, sharp, sass, tsx
- Scripts added: generate:types, payload, seed
- Build passes successfully - no changes needed to existing codebase
- The seed script points to src/seed/index.ts which doesn't exist yet (will be created in S28)

Test Results:
- pnpm install: SUCCESS
- pnpm build: SUCCESS (compiled in 1163.4ms)

=== Iteration 2 - S2 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Moved all source directories (app, components, hooks, lib) to src/ using git mv to preserve history
- Created Payload-specific directories: collections/, globals/, blocks/, access/, utilities/, seed/, plugins/
- The empty features/ directory at root was removed (not tracked by git as empty)
- Updated tsconfig.json paths: @/* now resolves to ./src/*
- Updated components.json to point to src/app/globals.css for shadcn/ui
- The @/ alias imports in components (like @/lib/utils) continue to work after tsconfig.json update
- IMPORTANT: Must delete .next cache directory after directory restructure - stale type references cause build failures
- Added .gitkeep files to empty directories to ensure they are tracked by git
- All existing tests (13) continue to pass after restructure

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 1096.8ms)

Gotchas for future stories:
- Always clear .next cache when making structural changes to the project
- The @/* path alias must be updated in tsconfig.json when using src/ directory
- The components.json css path must also be updated for shadcn/ui to work correctly

=== Iteration 3 - S3 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/payload.config.ts with Payload CMS 3.x buildConfig
- PostgreSQL adapter configured via DATABASE_URL environment variable (falls back to empty string for builds)
- Lexical rich text editor configured as the default editor
- Admin panel configured with meta title "Payload CMS Admin"
- TypeScript types output configured to src/payload-types.ts
- PAYLOAD_SECRET configured via environment variable with default fallback for development
- importMap configuration set with baseDir pointing to the dirname of the config file
- Used ESM-compatible path resolution with fileURLToPath and import.meta.url
- Build works without database connection - Payload handles missing DATABASE_URL gracefully during build
- All existing tests continue to pass (13 tests in 3 files)

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 1095.1ms)

Gotchas for future stories:
- The payload.config.ts uses ESM path resolution (fileURLToPath + import.meta.url) since the project has "type": "module"
- PAYLOAD_SECRET has a default value for development but should be set in production
- DATABASE_URL can be empty during builds - Payload handles this gracefully
- Future stories (S4) will need to integrate Payload routes into the Next.js app directory
- Collections and globals arrays are empty - will be populated in stories S5-S12 and S17

=== Iteration 4 - S4 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created route groups: (payload) for admin/API routes and (frontend) for public pages
- Route groups use parentheses () in folder names - they don't affect URL structure
- Payload admin UI uses [[...segments]] catch-all route for dynamic admin pages
- REST API uses [[...slug]] catch-all route for all HTTP methods
- GraphQL endpoint uses separate route for GET (playground) and POST (queries)
- Must wrap Next.js config with withPayload from @payloadcms/next/withPayload
- Added @payload-config path alias to tsconfig.json for config imports
- Upgraded Next.js 16.0.10 -> 16.1.6 (Payload requires 16.1.0+ for Turbopack builds)
- Added pg package as explicit dependency for PostgreSQL support
- importMap.ts is auto-generated by Payload but needs initial stub file
- custom.scss file needed for admin panel custom styles
- @payloadcms/next/css import provides required admin panel styles
- components.json updated to point to (frontend)/globals.css for shadcn/ui

Route Structure:
- /admin/* → src/app/(payload)/admin/[[...segments]]/page.tsx
- /api/* → src/app/(payload)/api/[[...slug]]/route.ts
- /api/graphql → src/app/(payload)/api/graphql/route.ts
- /* (public) → src/app/(frontend)/page.tsx

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS

Gotchas for future stories:
- Route groups don't affect URL paths but allow separate layouts
- Payload generates importMap.ts during development/build - stub file needed initially
- withPayload wrapper is required for Next.js config
- Next.js version must be 16.1.0+ for Payload CMS compatibility
- pg package must be explicitly installed for PostgreSQL adapter

=== Iteration 5 - S5 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/collections/Users/index.ts with Payload CollectionConfig
- Setting `auth: true` automatically adds email and password fields with authentication handling
- Role field implemented as select with options: admin, editor, user (defaultValue: 'user')
- Admin panel access control uses `admin.hidden` callback to hide from non-admin users
- Collection-level access control uses `access` object with read/create/update/delete/admin keys
- Access control functions receive `({ req: { user } })` to check authenticated user
- For conditional access (e.g., user can only read/update themselves), return a query object like `{ id: { equals: user.id } }`
- Field-level access control allows restricting who can update specific fields (e.g., only admins can change roles)
- TypeScript types are properly inferred from CollectionConfig - no manual type export needed
- Import Users collection and add to collections array in payload.config.ts

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 6.4s)

Gotchas for future stories:
- When `auth: true`, email and password fields are automatically provided - don't add them manually
- Access control queries use Payload's query syntax (e.g., `{ field: { equals: value } }`)
- The `admin` access key controls access to the admin panel for this collection specifically
- Future collections (Media, Pages, Posts, Categories) will follow similar patterns
- S18 will create reusable access control functions - for now, inline functions work fine

=== Iteration 6 - S6 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/collections/Media.ts with Payload CollectionConfig for file uploads
- Upload configuration uses `upload` key with mimeTypes, imageSizes, and adminThumbnail
- mimeTypes filter restricts uploads to images: jpeg, png, gif, webp, svg+xml
- imageSizes array defines responsive image sizes with name, width, height, position
- Three image sizes configured: thumbnail (400x300), card (768x576), hero (1920x1080)
- position: 'centre' crops from center when resizing
- adminThumbnail: 'thumbnail' tells admin panel which size to use in list views
- Fields added: alt (text, required), caption (text, optional)
- Access control: public read, authenticated create/update, admin-only delete
- Media collection is simple (single file) - no subdirectory like Users collection

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 6.0s)

Gotchas for future stories:
- Upload collections need `upload` config object (not `auth` like Users)
- imageSizes names become available as sizes[name].url in the Media document
- The sharp package (installed in S1) handles image processing automatically
- Future blocks (S14 MediaBlock) will reference this collection for images
- S17 will register all collections including Media in payload.config.ts (already done here)

=== Iteration 7 - S7 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/collections/Pages/index.ts with CollectionConfig for static pages
- Pages collection follows directory structure like Users (subdirectory with index.ts)
- Fields implemented: title, slug (unique, indexed), publishedAt, hero group, layout blocks, meta group
- Hero group includes type (select), heading, subheading, media (upload to Media), richText
- Layout field is blocks array - currently empty, will be populated as blocks are created in S13-S16
- Meta group for SEO includes title, description, image (upload to Media)
- Slug generation hook using FieldHook on beforeValidate - converts title to URL-friendly slug
- Revalidation hook using CollectionAfterChangeHook - logs revalidation (actual Next.js revalidatePath requires runtime)
- Admin preview function returns URL based on slug (handles 'home' special case)
- Versions with drafts enabled for draft/publish workflow
- Access control: published pages are public (using _status equals 'published' query)
- Admin condition callbacks hide/show fields based on hero type selection

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 5.7s)

Gotchas for future stories:
- The layout blocks array is empty - will be populated as Content, MediaBlock, CallToAction blocks are created
- FieldHook for slug uses beforeValidate to format before save
- For conditional field visibility in admin, use admin.condition callback with siblingData
- Upload fields use relationTo to specify the upload collection (e.g., 'media')
- Draft/publish uses versions.drafts: true and _status field is auto-managed by Payload
- Public read access for published pages uses query: { _status: { equals: 'published' } }
- S8 (Posts) will follow similar pattern with additional author and categories relationships

=== Iteration 8 - S8 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/collections/Posts/index.ts with CollectionConfig for blog posts
- Posts collection follows directory structure like Pages (subdirectory with index.ts)
- Fields implemented: title, slug (unique, indexed), excerpt (textarea), content (richText required)
- featuredImage uses upload field with relationTo: 'media'
- categories uses relationship field with relationTo: 'categories' and hasMany: true
- author uses relationship field with relationTo: 'users' and required: true
- publishedAt date field with dayAndTime picker appearance
- Meta group for SEO includes title, description, image (same pattern as Pages)
- IMPORTANT: Payload validates relationships at build time - referencing a non-existent collection causes runtime errors
- Had to create minimal Categories collection (src/collections/Categories.ts) to satisfy Posts relationship requirement
- This is acceptable because S9 will enhance Categories with parent/breadcrumbs - we just created the foundation
- Reused formatSlug and revalidatePage hooks pattern from Pages collection
- Admin preview URL returns /posts/{slug} format
- Access control same pattern as Pages: published posts are public, authenticated can create/update, admins can delete

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 5.8s)

Gotchas for future stories:
- When a collection references another collection, that target collection MUST exist and be registered
- S9 (Categories) can now enhance the existing Categories collection with parent/breadcrumbs features
- Relationship fields use `relationTo: 'collection-slug'` (lowercase) not the collection variable name
- hasMany: true allows multiple relationships (e.g., post can have multiple categories)
- Required relationship fields (like author) ensure data integrity
- Upload fields are a special type of relationship - use `type: 'upload'` with `relationTo`

=== Iteration 9 - S9 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Enhanced existing Categories collection (created in S8) with parent self-reference and breadcrumbs
- parent field is a relationship to 'categories' (self-reference) for nested hierarchy
- filterOptions on parent field prevents circular references by filtering out the current document ID
- breadcrumbs field is an array with doc (relationship), url (text), and label (text) fields
- breadcrumbs marked as readOnly since it will be managed by @payloadcms/plugin-nested-docs in S26
- The nested-docs plugin isn't installed yet (S26) but the field structure is prepared
- Updated admin defaultColumns to include 'parent' for better visibility in list view
- Self-referencing relationships work naturally in Payload - just use relationTo: 'collection-slug'

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 6.0s)

Gotchas for future stories:
- filterOptions callback receives { id } to filter relationship options dynamically
- For self-references, use not_equals query to prevent circular references: { id: { not_equals: id } }
- readOnly admin fields are useful for computed/managed fields that shouldn't be edited manually
- S26 will install @payloadcms/plugin-nested-docs which will auto-populate breadcrumbs
- The breadcrumbs field structure matches what the nested-docs plugin expects

=== Iteration 10 - S10 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/Header/config.ts with Payload GlobalConfig for site header
- Globals use GlobalConfig type (not CollectionConfig) and GlobalAfterChangeHook for hooks
- Fields implemented: logo (upload to media), navItems (array with label, link), ctaButton (group)
- ctaButton group includes label, link, and variant (select: default, secondary, outline, ghost)
- Created src/Header/Component.tsx - client component using 'use client' for React state
- Component uses shadcn/ui Sheet for mobile hamburger menu (responsive at md breakpoint)
- Desktop navigation inline, mobile uses Sheet sliding panel from right
- Logo handles both populated (object with url) and unpopulated (string ID) states
- Used lucide-react MenuIcon for hamburger button
- Registered Header global in payload.config.ts globals array
- Created src/Header/index.ts for clean exports of config and component

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 6.5s)

Gotchas for future stories:
- Globals use GlobalConfig and GlobalAfterChangeHook (different from Collection types)
- Upload relationship fields can be string (ID only) or object (populated) - handle both
- 'use client' required for components using React hooks (useState)
- Sheet component from shadcn/ui works well for mobile navigation
- The variant field options match shadcn/ui Button variants for consistency
- S11 (Footer) and S12 (SiteSettings) will follow similar Global patterns
- S21 (Frontend Layout) will fetch and pass Header data to this component

=== Iteration 11 - S11 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/Footer/config.ts with Payload GlobalConfig for site footer
- Follows same pattern as Header: GlobalConfig type, GlobalAfterChangeHook for revalidation
- Fields implemented: logo (upload), columns (array with title and links), socialLinks (array), copyright (text)
- columns array allows multi-column footer layout - max 4 columns with title and nested links array
- socialLinks array uses select for platform (determines icon) and text for URL
- Platform options: twitter, facebook, instagram, linkedin, youtube, github, tiktok
- Created src/Footer/Component.tsx - client component with multi-column grid layout
- Used lucide-react icons for social platforms (Twitter, Facebook, Instagram, Linkedin, Youtube, Github)
- TikTok icon not available in lucide-react - created custom SVG component
- getSocialIcon helper maps platform string to icon component
- Grid uses lg:col-span for responsive column widths (logo 3, each column 2)
- Bottom section with social links and copyright separated by border-t
- Handles both populated and unpopulated logo states (same pattern as Header)
- Created src/Footer/index.ts for clean exports of config and component

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 6.1s)

Gotchas for future stories:
- Some icons not available in lucide-react (TikTok) - use custom SVG components
- Multi-column footer uses nested arrays (columns > links)
- Grid column spans: use lg:col-span-X for responsive footer layouts
- Social icons should use target="_blank" rel="noopener noreferrer" for external links
- S12 (SiteSettings) will follow similar Global pattern
- S21 (Frontend Layout) will fetch and pass Footer data to this component

=== Iteration 12 - S12 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/globals/SiteSettings.ts with Payload GlobalConfig for site-wide settings
- Used the src/globals/ directory (different from Header/Footer which are in src/Header and src/Footer)
- Fields organized into logical groups: general, contact, socialLinks (array), analytics
- General group: siteName (required with default), siteDescription (with default), defaultOgImage (upload)
- Contact group: email (type: 'email'), phone (text), address (textarea)
- Social links reuses the same platform options pattern from Footer (consistent UX in admin)
- Analytics group: googleAnalyticsId, googleTagManagerId, facebookPixelId - all optional text fields
- Default values on required fields (siteName, siteDescription) ensure the global is always valid
- Using type: 'email' for email field provides built-in validation in the admin panel
- Revalidation hook follows same pattern as Header and Footer globals
- Access control: public read, authenticated update (consistent with other globals)

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 5.9s)

Gotchas for future stories:
- Globals can be placed in src/globals/ directory or standalone directories like Header/Footer
- Use type: 'email' for email fields - Payload provides validation
- Group fields help organize complex settings into logical sections in the admin UI
- Default values are useful for required fields to prevent validation errors on empty globals
- S17 will verify all collections and globals are properly registered (already done incrementally)
- S19 (utilities) may use SiteSettings for generateMeta function
- S21 (Frontend Layout) will fetch SiteSettings for meta tags and analytics injection

=== Iteration 13 - S13 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/blocks/Content/ directory with config.ts, Component.tsx, and index.ts
- Payload blocks use Block type (not CollectionConfig or GlobalConfig)
- Block config requires slug, labels, and fields; interfaceName is optional but helps with TypeScript
- Fields use admin.condition callback for conditional visibility (same pattern as other Payload fields)
- Rich text fields store content in Lexical JSON format with root.children array
- Created a minimal RichText renderer that handles common Lexical node types (paragraph, heading, list, quote, text with formatting)
- Text formatting uses bitwise flags: IS_BOLD=1, IS_ITALIC=2, IS_STRIKETHROUGH=4, IS_UNDERLINE=8, IS_CODE=16
- Component uses responsive grid with Tailwind: grid-cols-1 on mobile, grid-cols-2 on md, grid-cols-3 on lg
- Import and add block to Pages collection's layout.blocks array
- Block directory structure mirrors Header/Footer pattern: config.ts, Component.tsx, index.ts
- All tests continue to pass (13 tests in 3 files)

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 5.7s)

Gotchas for future stories:
- Payload blocks are imported and added to blocks array in collection fields (e.g., Pages layout field)
- Rich text rendering is non-trivial - may need @payloadcms/richtext-lexical/react for production rendering
- The RichText component created here is a basic implementation; S16 (RenderBlocks) may refine it
- S14 (MediaBlock) and S15 (CallToAction) will follow the same block structure pattern
- Each block component should handle its own responsive layout
