=== Iteration 1 - S1 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Payload CMS 3.74.0 and all required packages installed successfully
- Peer dependency warning: @payloadcms/next and @payloadcms/ui require Next.js ^15.4.10 or >=16.1.1, but we have 16.0.10. This may need addressing in future stories if compatibility issues arise.
- Adding "type": "module" to package.json works with existing Next.js setup
- All packages installed: payload, @payloadcms/db-postgres, @payloadcms/next, @payloadcms/richtext-lexical, @payloadcms/ui, graphql, sharp, sass, tsx
- Scripts added: generate:types, payload, seed
- Build passes successfully - no changes needed to existing codebase
- The seed script points to src/seed/index.ts which doesn't exist yet (will be created in S28)

Test Results:
- pnpm install: SUCCESS
- pnpm build: SUCCESS (compiled in 1163.4ms)

=== Iteration 2 - S2 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Moved all source directories (app, components, hooks, lib) to src/ using git mv to preserve history
- Created Payload-specific directories: collections/, globals/, blocks/, access/, utilities/, seed/, plugins/
- The empty features/ directory at root was removed (not tracked by git as empty)
- Updated tsconfig.json paths: @/* now resolves to ./src/*
- Updated components.json to point to src/app/globals.css for shadcn/ui
- The @/ alias imports in components (like @/lib/utils) continue to work after tsconfig.json update
- IMPORTANT: Must delete .next cache directory after directory restructure - stale type references cause build failures
- Added .gitkeep files to empty directories to ensure they are tracked by git
- All existing tests (13) continue to pass after restructure

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 1096.8ms)

Gotchas for future stories:
- Always clear .next cache when making structural changes to the project
- The @/* path alias must be updated in tsconfig.json when using src/ directory
- The components.json css path must also be updated for shadcn/ui to work correctly

=== Iteration 3 - S3 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/payload.config.ts with Payload CMS 3.x buildConfig
- PostgreSQL adapter configured via DATABASE_URL environment variable (falls back to empty string for builds)
- Lexical rich text editor configured as the default editor
- Admin panel configured with meta title "Payload CMS Admin"
- TypeScript types output configured to src/payload-types.ts
- PAYLOAD_SECRET configured via environment variable with default fallback for development
- importMap configuration set with baseDir pointing to the dirname of the config file
- Used ESM-compatible path resolution with fileURLToPath and import.meta.url
- Build works without database connection - Payload handles missing DATABASE_URL gracefully during build
- All existing tests continue to pass (13 tests in 3 files)

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 1095.1ms)

Gotchas for future stories:
- The payload.config.ts uses ESM path resolution (fileURLToPath + import.meta.url) since the project has "type": "module"
- PAYLOAD_SECRET has a default value for development but should be set in production
- DATABASE_URL can be empty during builds - Payload handles this gracefully
- Future stories (S4) will need to integrate Payload routes into the Next.js app directory
- Collections and globals arrays are empty - will be populated in stories S5-S12 and S17

=== Iteration 4 - S4 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created route groups: (payload) for admin/API routes and (frontend) for public pages
- Route groups use parentheses () in folder names - they don't affect URL structure
- Payload admin UI uses [[...segments]] catch-all route for dynamic admin pages
- REST API uses [[...slug]] catch-all route for all HTTP methods
- GraphQL endpoint uses separate route for GET (playground) and POST (queries)
- Must wrap Next.js config with withPayload from @payloadcms/next/withPayload
- Added @payload-config path alias to tsconfig.json for config imports
- Upgraded Next.js 16.0.10 -> 16.1.6 (Payload requires 16.1.0+ for Turbopack builds)
- Added pg package as explicit dependency for PostgreSQL support
- importMap.ts is auto-generated by Payload but needs initial stub file
- custom.scss file needed for admin panel custom styles
- @payloadcms/next/css import provides required admin panel styles
- components.json updated to point to (frontend)/globals.css for shadcn/ui

Route Structure:
- /admin/* → src/app/(payload)/admin/[[...segments]]/page.tsx
- /api/* → src/app/(payload)/api/[[...slug]]/route.ts
- /api/graphql → src/app/(payload)/api/graphql/route.ts
- /* (public) → src/app/(frontend)/page.tsx

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS

Gotchas for future stories:
- Route groups don't affect URL paths but allow separate layouts
- Payload generates importMap.ts during development/build - stub file needed initially
- withPayload wrapper is required for Next.js config
- Next.js version must be 16.1.0+ for Payload CMS compatibility
- pg package must be explicitly installed for PostgreSQL adapter

=== Iteration 5 - S5 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/collections/Users/index.ts with Payload CollectionConfig
- Setting `auth: true` automatically adds email and password fields with authentication handling
- Role field implemented as select with options: admin, editor, user (defaultValue: 'user')
- Admin panel access control uses `admin.hidden` callback to hide from non-admin users
- Collection-level access control uses `access` object with read/create/update/delete/admin keys
- Access control functions receive `({ req: { user } })` to check authenticated user
- For conditional access (e.g., user can only read/update themselves), return a query object like `{ id: { equals: user.id } }`
- Field-level access control allows restricting who can update specific fields (e.g., only admins can change roles)
- TypeScript types are properly inferred from CollectionConfig - no manual type export needed
- Import Users collection and add to collections array in payload.config.ts

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 6.4s)

Gotchas for future stories:
- When `auth: true`, email and password fields are automatically provided - don't add them manually
- Access control queries use Payload's query syntax (e.g., `{ field: { equals: value } }`)
- The `admin` access key controls access to the admin panel for this collection specifically
- Future collections (Media, Pages, Posts, Categories) will follow similar patterns
- S18 will create reusable access control functions - for now, inline functions work fine

=== Iteration 6 - S6 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/collections/Media.ts with Payload CollectionConfig for file uploads
- Upload configuration uses `upload` key with mimeTypes, imageSizes, and adminThumbnail
- mimeTypes filter restricts uploads to images: jpeg, png, gif, webp, svg+xml
- imageSizes array defines responsive image sizes with name, width, height, position
- Three image sizes configured: thumbnail (400x300), card (768x576), hero (1920x1080)
- position: 'centre' crops from center when resizing
- adminThumbnail: 'thumbnail' tells admin panel which size to use in list views
- Fields added: alt (text, required), caption (text, optional)
- Access control: public read, authenticated create/update, admin-only delete
- Media collection is simple (single file) - no subdirectory like Users collection

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 6.0s)

Gotchas for future stories:
- Upload collections need `upload` config object (not `auth` like Users)
- imageSizes names become available as sizes[name].url in the Media document
- The sharp package (installed in S1) handles image processing automatically
- Future blocks (S14 MediaBlock) will reference this collection for images
- S17 will register all collections including Media in payload.config.ts (already done here)

=== Iteration 7 - S7 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/collections/Pages/index.ts with CollectionConfig for static pages
- Pages collection follows directory structure like Users (subdirectory with index.ts)
- Fields implemented: title, slug (unique, indexed), publishedAt, hero group, layout blocks, meta group
- Hero group includes type (select), heading, subheading, media (upload to Media), richText
- Layout field is blocks array - currently empty, will be populated as blocks are created in S13-S16
- Meta group for SEO includes title, description, image (upload to Media)
- Slug generation hook using FieldHook on beforeValidate - converts title to URL-friendly slug
- Revalidation hook using CollectionAfterChangeHook - logs revalidation (actual Next.js revalidatePath requires runtime)
- Admin preview function returns URL based on slug (handles 'home' special case)
- Versions with drafts enabled for draft/publish workflow
- Access control: published pages are public (using _status equals 'published' query)
- Admin condition callbacks hide/show fields based on hero type selection

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 5.7s)

Gotchas for future stories:
- The layout blocks array is empty - will be populated as Content, MediaBlock, CallToAction blocks are created
- FieldHook for slug uses beforeValidate to format before save
- For conditional field visibility in admin, use admin.condition callback with siblingData
- Upload fields use relationTo to specify the upload collection (e.g., 'media')
- Draft/publish uses versions.drafts: true and _status field is auto-managed by Payload
- Public read access for published pages uses query: { _status: { equals: 'published' } }
- S8 (Posts) will follow similar pattern with additional author and categories relationships

=== Iteration 8 - S8 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/collections/Posts/index.ts with CollectionConfig for blog posts
- Posts collection follows directory structure like Pages (subdirectory with index.ts)
- Fields implemented: title, slug (unique, indexed), excerpt (textarea), content (richText required)
- featuredImage uses upload field with relationTo: 'media'
- categories uses relationship field with relationTo: 'categories' and hasMany: true
- author uses relationship field with relationTo: 'users' and required: true
- publishedAt date field with dayAndTime picker appearance
- Meta group for SEO includes title, description, image (same pattern as Pages)
- IMPORTANT: Payload validates relationships at build time - referencing a non-existent collection causes runtime errors
- Had to create minimal Categories collection (src/collections/Categories.ts) to satisfy Posts relationship requirement
- This is acceptable because S9 will enhance Categories with parent/breadcrumbs - we just created the foundation
- Reused formatSlug and revalidatePage hooks pattern from Pages collection
- Admin preview URL returns /posts/{slug} format
- Access control same pattern as Pages: published posts are public, authenticated can create/update, admins can delete

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 5.8s)

Gotchas for future stories:
- When a collection references another collection, that target collection MUST exist and be registered
- S9 (Categories) can now enhance the existing Categories collection with parent/breadcrumbs features
- Relationship fields use `relationTo: 'collection-slug'` (lowercase) not the collection variable name
- hasMany: true allows multiple relationships (e.g., post can have multiple categories)
- Required relationship fields (like author) ensure data integrity
- Upload fields are a special type of relationship - use `type: 'upload'` with `relationTo`

=== Iteration 9 - S9 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Enhanced existing Categories collection (created in S8) with parent self-reference and breadcrumbs
- parent field is a relationship to 'categories' (self-reference) for nested hierarchy
- filterOptions on parent field prevents circular references by filtering out the current document ID
- breadcrumbs field is an array with doc (relationship), url (text), and label (text) fields
- breadcrumbs marked as readOnly since it will be managed by @payloadcms/plugin-nested-docs in S26
- The nested-docs plugin isn't installed yet (S26) but the field structure is prepared
- Updated admin defaultColumns to include 'parent' for better visibility in list view
- Self-referencing relationships work naturally in Payload - just use relationTo: 'collection-slug'

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 6.0s)

Gotchas for future stories:
- filterOptions callback receives { id } to filter relationship options dynamically
- For self-references, use not_equals query to prevent circular references: { id: { not_equals: id } }
- readOnly admin fields are useful for computed/managed fields that shouldn't be edited manually
- S26 will install @payloadcms/plugin-nested-docs which will auto-populate breadcrumbs
- The breadcrumbs field structure matches what the nested-docs plugin expects

=== Iteration 10 - S10 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/Header/config.ts with Payload GlobalConfig for site header
- Globals use GlobalConfig type (not CollectionConfig) and GlobalAfterChangeHook for hooks
- Fields implemented: logo (upload to media), navItems (array with label, link), ctaButton (group)
- ctaButton group includes label, link, and variant (select: default, secondary, outline, ghost)
- Created src/Header/Component.tsx - client component using 'use client' for React state
- Component uses shadcn/ui Sheet for mobile hamburger menu (responsive at md breakpoint)
- Desktop navigation inline, mobile uses Sheet sliding panel from right
- Logo handles both populated (object with url) and unpopulated (string ID) states
- Used lucide-react MenuIcon for hamburger button
- Registered Header global in payload.config.ts globals array
- Created src/Header/index.ts for clean exports of config and component

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 6.5s)

Gotchas for future stories:
- Globals use GlobalConfig and GlobalAfterChangeHook (different from Collection types)
- Upload relationship fields can be string (ID only) or object (populated) - handle both
- 'use client' required for components using React hooks (useState)
- Sheet component from shadcn/ui works well for mobile navigation
- The variant field options match shadcn/ui Button variants for consistency
- S11 (Footer) and S12 (SiteSettings) will follow similar Global patterns
- S21 (Frontend Layout) will fetch and pass Header data to this component

=== Iteration 11 - S11 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/Footer/config.ts with Payload GlobalConfig for site footer
- Follows same pattern as Header: GlobalConfig type, GlobalAfterChangeHook for revalidation
- Fields implemented: logo (upload), columns (array with title and links), socialLinks (array), copyright (text)
- columns array allows multi-column footer layout - max 4 columns with title and nested links array
- socialLinks array uses select for platform (determines icon) and text for URL
- Platform options: twitter, facebook, instagram, linkedin, youtube, github, tiktok
- Created src/Footer/Component.tsx - client component with multi-column grid layout
- Used lucide-react icons for social platforms (Twitter, Facebook, Instagram, Linkedin, Youtube, Github)
- TikTok icon not available in lucide-react - created custom SVG component
- getSocialIcon helper maps platform string to icon component
- Grid uses lg:col-span for responsive column widths (logo 3, each column 2)
- Bottom section with social links and copyright separated by border-t
- Handles both populated and unpopulated logo states (same pattern as Header)
- Created src/Footer/index.ts for clean exports of config and component

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 6.1s)

Gotchas for future stories:
- Some icons not available in lucide-react (TikTok) - use custom SVG components
- Multi-column footer uses nested arrays (columns > links)
- Grid column spans: use lg:col-span-X for responsive footer layouts
- Social icons should use target="_blank" rel="noopener noreferrer" for external links
- S12 (SiteSettings) will follow similar Global pattern
- S21 (Frontend Layout) will fetch and pass Footer data to this component

=== Iteration 12 - S12 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/globals/SiteSettings.ts with Payload GlobalConfig for site-wide settings
- Used the src/globals/ directory (different from Header/Footer which are in src/Header and src/Footer)
- Fields organized into logical groups: general, contact, socialLinks (array), analytics
- General group: siteName (required with default), siteDescription (with default), defaultOgImage (upload)
- Contact group: email (type: 'email'), phone (text), address (textarea)
- Social links reuses the same platform options pattern from Footer (consistent UX in admin)
- Analytics group: googleAnalyticsId, googleTagManagerId, facebookPixelId - all optional text fields
- Default values on required fields (siteName, siteDescription) ensure the global is always valid
- Using type: 'email' for email field provides built-in validation in the admin panel
- Revalidation hook follows same pattern as Header and Footer globals
- Access control: public read, authenticated update (consistent with other globals)

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 5.9s)

Gotchas for future stories:
- Globals can be placed in src/globals/ directory or standalone directories like Header/Footer
- Use type: 'email' for email fields - Payload provides validation
- Group fields help organize complex settings into logical sections in the admin UI
- Default values are useful for required fields to prevent validation errors on empty globals
- S17 will verify all collections and globals are properly registered (already done incrementally)
- S19 (utilities) may use SiteSettings for generateMeta function
- S21 (Frontend Layout) will fetch SiteSettings for meta tags and analytics injection

=== Iteration 13 - S13 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/blocks/Content/ directory with config.ts, Component.tsx, and index.ts
- Payload blocks use Block type (not CollectionConfig or GlobalConfig)
- Block config requires slug, labels, and fields; interfaceName is optional but helps with TypeScript
- Fields use admin.condition callback for conditional visibility (same pattern as other Payload fields)
- Rich text fields store content in Lexical JSON format with root.children array
- Created a minimal RichText renderer that handles common Lexical node types (paragraph, heading, list, quote, text with formatting)
- Text formatting uses bitwise flags: IS_BOLD=1, IS_ITALIC=2, IS_STRIKETHROUGH=4, IS_UNDERLINE=8, IS_CODE=16
- Component uses responsive grid with Tailwind: grid-cols-1 on mobile, grid-cols-2 on md, grid-cols-3 on lg
- Import and add block to Pages collection's layout.blocks array
- Block directory structure mirrors Header/Footer pattern: config.ts, Component.tsx, index.ts
- All tests continue to pass (13 tests in 3 files)

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (13 tests in 3 files)
- pnpm build: SUCCESS (compiled in 5.7s)

Gotchas for future stories:
- Payload blocks are imported and added to blocks array in collection fields (e.g., Pages layout field)
- Rich text rendering is non-trivial - may need @payloadcms/richtext-lexical/react for production rendering
- The RichText component created here is a basic implementation; S16 (RenderBlocks) may refine it
- S14 (MediaBlock) and S15 (CallToAction) will follow the same block structure pattern
- Each block component should handle its own responsive layout

=== Iteration 14 - S14 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/blocks/MediaBlock/ directory with config.ts, Component.tsx, and index.ts
- MediaBlock follows the same block structure pattern as Content block
- Fields implemented: media (upload to 'media'), caption (text), position (select: left/center/right)
- Using next/image for optimized responsive images with proper width, height, and sizes attributes
- Media upload fields can be string (ID only) or object (populated) - component handles both cases
- Position field uses alignment classes (mr-auto, mx-auto, ml-auto) for left/center/right positioning
- Optional caption displayed below image using figcaption element
- Using figure/figcaption semantic HTML for image with caption
- Added MediaBlock to Pages collection layout.blocks array alongside Content block
- Block interfaceName set to 'MediaBlock' for TypeScript type generation

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (compiled in 5.8s)

Gotchas for future stories:
- Upload fields in Payload can return either string (ID) or populated object - always check and handle both
- next/image requires width and height - use defaults if media dimensions aren't available
- The sizes prop on Image helps browser choose appropriate image for viewport
- S15 (CallToAction) will follow the same block structure pattern
- S16 (RenderBlocks) will need to map 'mediaBlock' slug to MediaBlockComponent

=== Iteration 15 - S15 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/blocks/CallToAction/ directory with config.ts, Component.tsx, and index.ts
- CallToAction follows the same block structure pattern as Content and MediaBlock
- Fields implemented: heading (required), subheading, richText, buttons (array), backgroundColor (select)
- Buttons array has fields: label, link, variant (default/secondary/outline/ghost)
- Background options: default, muted, primary, secondary, accent
- Component uses shadcn/ui Button component with asChild and Link for navigation
- Responsive button layout: flex-col on mobile, flex-row on sm+
- Centered layout using max-w-3xl and text-center
- Rich text rendering reused from Content block pattern
- Block slug is 'callToAction' (camelCase) for consistency
- interfaceName set to 'CallToActionBlock' for TypeScript type generation
- Added CallToAction to Pages collection layout.blocks array

Test Results:
- pnpm build: SUCCESS (compiled in 6.5s)

Gotchas for future stories:
- For CTA buttons, use shadcn/ui Button with asChild pattern and Link for proper navigation
- Background color classes need to include text color for primary/secondary/accent backgrounds
- minRows/maxRows on array fields limits number of items (e.g., maxRows: 3 for buttons)
- S16 (RenderBlocks) will need to map 'callToAction' slug to CallToActionComponent

=== Iteration 16 - S16 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/blocks/RenderBlocks.tsx component for dynamic block rendering
- Created src/blocks/index.ts exporting all block configs and components
- Used discriminated union pattern (blockType) for type-safe block rendering
- Switch statement approach is cleaner than Record<string, ComponentType> for TypeScript
- Direct Record<string, ComponentType<Union>> doesn't work well with React components of different prop types
- Each block component is exported with different naming from its index.ts (e.g., ContentBlock -> ContentComponent)
- Must check existing exports before re-exporting - Content exports ContentComponent, not ContentBlock
- blockConfigs array provides easy registration in Payload collections
- Unknown block types handled gracefully with dev-only console.warn
- Block key uses block.id (from Payload) or index fallback for stable React keys

Test Results:
- pnpm build: SUCCESS (compiled in 5.7s)

Gotchas for future stories:
- When mapping block types to components, use switch statement for proper TypeScript inference
- Check the exact export names from each block's index.ts file before importing
- The blockType field is a string literal that matches the block's slug in config
- S22/S23 (Homepage/Dynamic Pages) will use RenderBlocks to render page.layout blocks
- S29 (Tests) should add tests for RenderBlocks component with mock block data

=== Iteration 17 - S17 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- S17 was essentially completed incrementally during stories S5-S12
- Collections were added to payload.config.ts as they were created (Users, Media, Pages, Posts, Categories)
- Globals were added to payload.config.ts as they were created (Header, Footer, SiteSettings)
- payload.config.ts imports use correct paths:
  - './collections/Users' (directory with index.ts)
  - './collections/Media' (single file .ts)
  - './collections/Pages' (directory with index.ts)
  - './collections/Posts' (directory with index.ts)
  - './collections/Categories' (single file .ts)
  - './Header/config' (global with separate Component.tsx)
  - './Footer/config' (global with separate Component.tsx)
  - './globals/SiteSettings' (standalone global file)
- Payload's buildConfig function provides proper TypeScript inference for collections and globals arrays
- No explicit type annotations needed - TypeScript infers CollectionConfig[] and GlobalConfig[] from buildConfig

Test Results:
- pnpm build: SUCCESS (compiled in 6.0s)

Gotchas for future stories:
- Collections/globals can be organized as single files or directories with index.ts
- When a collection/global has associated components (Header, Footer), use directory structure
- Payload's type inference handles array typing automatically through buildConfig
- The db adapter (postgresAdapter) gracefully handles missing DATABASE_URL during builds

=== Iteration 18 - S18 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created four reusable access control functions in src/access/:
  - authenticated.ts - requires any authenticated user
  - authenticatedOrPublished.ts - returns true for authenticated users, or query for published content
  - admins.ts - requires admin role
  - adminsOrSelf.ts - admins get full access, others restricted to their own data
- IMPORTANT: The `Access` type from Payload can return `boolean | Where | Promise<boolean | Where>`
- IMPORTANT: The `admin` access key on collections has a DIFFERENT type: only `boolean | Promise<boolean>` (no Where query objects allowed)
- IMPORTANT: Field-level access (`FieldAccess` type) also only allows `boolean | Promise<boolean>`
- Created `adminsAdminAccess` function with correct typing for `admin` and field-level access
- Both `adminsAdminAccess` and `admins` have the same implementation (check role === 'admin')
- But they have different type signatures to satisfy TypeScript
- Applied access functions to Users, Media, Pages, and Posts collections
- Removed .gitkeep from src/access/ since we now have real files

Test Results:
- pnpm build: SUCCESS (compiled in 5.7s)

Gotchas for future stories:
- Always check if an access position requires boolean-only return type
- Collection-level `admin` access key requires boolean-only (use adminsAdminAccess)
- Field-level `access.update/read/create` requires boolean-only (use adminsAdminAccess or inline)
- Collection-level `read/create/update/delete` accepts the full Access type (can return Where query)
- S19 (Utility Functions) will create helper utilities that may use these access patterns
- When creating new access functions, ensure correct typing based on where they will be used

=== Iteration 19 - S19 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created five utility files in src/utilities/:
  - getURL.ts - getServerSideURL() and getClientSideURL() for URL resolution
  - generateMeta.ts - Generates Next.js Metadata objects from Payload document meta fields
  - mergeOpenGraph.ts - Merges custom OpenGraph metadata with defaults
  - formatDateTime.ts - formatDateTime() and formatRelativeTime() using Intl APIs
  - cn.ts - Re-exports cn from @/lib/utils (avoids duplication)
- Created index.ts to export all utilities from one location
- IMPORTANT: Metadata['openGraph'] type from Next.js can be null/undefined
- Used NonNullable<Metadata['openGraph']> to create a strict type for defaultOpenGraph
- The cn utility already existed in src/lib/utils.ts (from shadcn/ui) - re-exported instead of duplicating
- Used NEXT_PUBLIC_SERVER_URL and VERCEL_PROJECT_PRODUCTION_URL for URL resolution
- getClientSideURL uses window.location.origin in browser, falls back to server URL on server
- generateMeta handles both populated (object) and unpopulated (string ID) image references
- formatDateTime uses Intl.DateTimeFormat for locale-aware formatting
- formatRelativeTime uses Intl.RelativeTimeFormat for relative time strings (e.g., "2 days ago")
- Removed .gitkeep from src/utilities/ since we now have real files

Test Results:
- pnpm build: SUCCESS (compiled in 5.5s)

Gotchas for future stories:
- When using Next.js Metadata types, many are nullable - use NonNullable<> for strict typing
- S20 (Payload Hooks) may use these utilities for revalidation and slug formatting
- S21 (Frontend Layout) will use generateMeta for page metadata
- S22/S23 (Pages) will use generateMeta in generateMetadata functions
- The utilities/index.ts provides a single import point: `import { cn, formatDateTime, ... } from '@/utilities'`

=== Iteration 20 - S20 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created three reusable Payload hook files in src/hooks/:
  - formatSlug.ts - FieldHook for slug generation from title field
  - populatePublishedAt.ts - CollectionBeforeChangeHook for auto-setting publishedAt
  - revalidatePath.ts - CollectionAfterChangeHook for Next.js path revalidation
- Created src/hooks/index.ts to export all Payload hooks (separate from React hooks like use-mobile.ts)
- IMPORTANT: Next.js 16 changed revalidateTag API - now requires a second argument (cacheLife profile)
  - Use revalidateTag(tag, 'max') for SWR behavior (recommended)
  - Use revalidateTag(tag, { expire: 0 }) for immediate expiration (webhooks)
  - Single-argument form is deprecated
- formatSlug hook handles both manual input (formats it) and auto-generation from title
- populatePublishedAt checks _status === 'published' and only sets if not already set
- revalidatePath provides factory functions (revalidatePathAfterChange, revalidatePathAfterDelete)
- Pre-configured hooks (revalidatePage, revalidatePost) for common use cases
- Applied hooks to Pages and Posts collections (replaced inline implementations)
- Hooks can be imported via @/hooks barrel export

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS

Gotchas for future stories:
- When using next/cache APIs, check Next.js 16 docs - many APIs changed signatures
- Payload hooks have specific types: FieldHook, CollectionBeforeChangeHook, CollectionAfterChangeHook, etc.
- React hooks (use-mobile.ts) should NOT be in the barrel export with Payload hooks (server vs client)
- The src/hooks/ directory now contains both React hooks (*.ts with 'use' prefix) and Payload hooks
- S21-S25 (Frontend pages) will benefit from the revalidation hooks being in place

=== Iteration 21 - S21 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/utilities/getPayload.ts for server-side Payload data fetching
- Uses Payload's getPayload({ config }) function with @payload-config alias
- Updated frontend layout (src/app/(frontend)/layout.tsx) to fetch globals:
  - Header global (slug: 'header')
  - Footer global (slug: 'footer')
  - SiteSettings global (slug: 'site-settings')
- Created typed interfaces for SiteSettings to match Payload global structure
- Each fetch function has try/catch with meaningful fallback data
- Uses Promise.all for parallel fetching of Header and Footer (better performance)
- Added generateMetadata function that uses SiteSettings for dynamic site title/description
- The layout is now a Server Component (async function) that fetches data
- Pass fetched data as props to Header and Footer client components
- Error handling logs to console.error for debugging during development
- Build succeeds without database - fallback data is used during static generation

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (with expected Postgres connection errors that are handled gracefully)

Gotchas for future stories:
- Global slugs use kebab-case in Payload (e.g., 'site-settings' not 'siteSettings')
- Import types from component files (HeaderData, FooterData) for type safety
- Use depth: 1 for relationship fields (e.g., logo upload) to get populated data
- The @payload-config alias is already set up in tsconfig.json from S4
- During build without DB, Payload throws errors but try/catch ensures the build continues
- S22 (Homepage) will use similar pattern for fetching page data

=== Iteration 22 - S22 - 2026-02-02 ===
Status: COMPLETE
Learnings:
- Created src/components/Hero.tsx component for rendering hero sections
  - Supports three hero types: highImpact (full-width bg), mediumImpact (split), lowImpact (simple text)
  - Handles both populated (object with url) and unpopulated (string ID) media states
  - Uses next/image with priority loading for hero images
- Updated src/app/(frontend)/page.tsx to fetch homepage from Payload CMS
  - Homepage is identified by slug: 'home' in Pages collection
  - Uses payload.find() with where clause for slug matching
  - depth: 2 ensures nested relationships (hero.media) are populated
- Integrated RenderBlocks component for dynamic content blocks
- Added try/catch with user-friendly FallbackContent component
- Added generateMetadata function using the existing generateMeta utility
- All acceptance criteria met:
  - ✓ src/app/(frontend)/page.tsx fetches homepage from Pages
  - ✓ Renders hero section from page data
  - ✓ Renders content blocks using RenderBlocks
  - ✓ try/catch with fallback content when no data
  - ✓ generateMetadata function for SEO
  - ✓ Server Component for data fetching

Test Results:
- pnpm build: SUCCESS (Postgres errors handled gracefully with fallback content)

Gotchas for future stories:
- Homepage uses slug: 'home' - users must create a page with this slug to customize
- Use depth: 2 for pages to ensure nested media relationships are fully populated
- FallbackContent provides helpful instructions for new users
- The same patterns (getHomepage, try/catch, fallbacks) apply to S23 (dynamic pages)
- Hero component can be reused for any page with hero sections

=== Iteration 23 - S23 - 2026-02-02 20:42:56 ===
Status: COMPLETE
Learnings:
- Created src/app/(frontend)/[slug]/page.tsx for dynamic page routing
- Followed the exact patterns established in homepage (page.tsx):
  - PageData interface for type safety
  - getPageBySlug function with try/catch for fetching
  - generateMetadata for SEO using generateMeta utility
  - Hero and RenderBlocks components for rendering
- Implemented generateStaticParams for static generation:
  - Fetches all page slugs from Payload at build time
  - Filters out 'home' slug (handled by homepage route)
  - Returns array of { slug: string } for Next.js
  - Uses depth: 0 and select for minimal data fetching
- Used notFound() from 'next/navigation' for missing pages
- Next.js 16 params are now Promise-based (async params)
  - Must await params before accessing properties: const { slug } = await params
  - Both generateMetadata and Page component use this pattern
- All acceptance criteria met:
  - ✓ src/app/(frontend)/[slug]/page.tsx for dynamic pages
  - ✓ Fetches page by slug from Pages collection
  - ✓ Renders hero and blocks
  - ✓ notFound() for missing pages
  - ✓ generateStaticParams for static generation
  - ✓ generateMetadata for SEO

Test Results:
- pnpm build: SUCCESS (Postgres errors handled gracefully by try/catch)
- Route table shows: ● /[slug] (SSG - prerendered as static HTML)

Gotchas for future stories:
- Next.js 16 uses async params in dynamic routes (must await params)
- generateStaticParams returns empty array on DB error - pages will be generated on-demand
- The 'home' slug is excluded from generateStaticParams (handled by / route)
- S24 (Blog Listing) and S25 (Blog Post Detail) will follow similar patterns
- Use depth: 0 and select for minimal data when only fetching slugs

=== Iteration 24 - S24 - 2026-02-02 20:46:30 ===
Status: COMPLETE
Learnings:
- Created blog listing page at src/app/(frontend)/posts/page.tsx
- Created reusable components:
  - PostCard: Displays post preview with featured image, title, excerpt, date
  - Pagination: URL-based pagination with Previous/Next buttons
- Next.js 16 uses Promise-based searchParams (must await searchParams)
- Used Payload's paginated find() with page, limit, and sort options
- Filter by _status: 'published' to only show published posts
- Sort by '-publishedAt' for newest first (minus prefix = descending)
- depth: 1 populates the featuredImage relationship
- Created PostCardData interface to handle both populated and unpopulated media
- Responsive grid layout using Tailwind: grid-cols-1, sm:grid-cols-2, lg:grid-cols-3
- EmptyState component provides user-friendly feedback when no posts exist
- Pagination uses URL query params (?page=2) for navigation
- Page is rendered dynamically (ƒ) due to pagination - this is correct behavior

Test Results:
- pnpm build: SUCCESS (Postgres errors handled gracefully by try/catch)
- Route table shows: ƒ /posts (Dynamic - server-rendered on demand)

Gotchas for future stories:
- Next.js 16 searchParams are now Promise-based like params
- Use POSTS_PER_PAGE constant for easy configuration
- Pagination basePath should match the route (e.g., '/posts')
- S25 (Blog Post Detail) will create the /posts/[slug] route
- PostCard component can be reused in related posts, search results, etc.

=== Iteration 25 - S25 - 2026-02-02 20:48:30 ===
Status: COMPLETE
Learnings:
- Created blog post detail page at src/app/(frontend)/posts/[slug]/page.tsx
- Created reusable RichText component at src/components/RichText.tsx for rendering Lexical content
- Followed patterns from dynamic page route ([slug]/page.tsx) and blog listing (posts/page.tsx)
- Key components:
  - PostData interface with all post fields (title, slug, content, featuredImage, author, categories, meta)
  - getPostBySlug function fetches post by slug with depth: 2 to populate relationships
  - getRelatedPosts function fetches posts sharing categories (limited to 3)
  - generateStaticParams for static generation of published posts
  - generateMetadata using generateMeta utility with collectionSlug: 'posts'
- RichText component handles Lexical JSON format with:
  - Text formatting (bold, italic, strikethrough, underline, code)
  - Paragraphs, headings (h1-h6), lists (ordered/unordered), blockquotes
  - Links with newTab support
  - Tailwind prose styling for typography
- Handled both populated and unpopulated relationship states:
  - featuredImage: MediaData | string | null
  - author: AuthorData | string | null
  - categories: (CategoryData | string)[]
- Related posts section uses categories.in query with post exclusion (id.not_equals)
- Featured image uses full-width aspect-[21/9] hero style
- All acceptance criteria met:
  - ✓ src/app/(frontend)/posts/[slug]/page.tsx for post detail
  - ✓ Fetches post by slug from Posts collection
  - ✓ Renders title, featured image, content (richText)
  - ✓ Shows author and date
  - ✓ Related posts section (optional, based on categories)
  - ✓ generateMetadata for SEO
  - ✓ notFound() for missing posts

Test Results:
- pnpm build: SUCCESS (Postgres errors handled gracefully by try/catch)
- Route table shows: ● /posts/[slug] (SSG - prerendered as static HTML)

Gotchas for future stories:
- Related posts query uses 'in' operator for categories array filtering
- depth: 2 required to populate nested relationships (author, categories, featuredImage)
- RichText component can be reused wherever rich text content needs rendering
- PostCard component works well for related posts display
- S31 could enhance RichText with official @payloadcms/richtext-lexical/react renderer

=== Iteration 26 - S26 - 2026-02-02 20:52:00 ===
Status: COMPLETE
Learnings:
- Installed @payloadcms/plugin-seo, @payloadcms/plugin-redirects, @payloadcms/plugin-nested-docs packages
- Created src/plugins/index.ts exporting plugins array for registration in payload.config.ts
- SEO plugin configuration:
  - Applied to 'pages' and 'posts' collections
  - Uses generateTitle and generateURL functions for auto-generation
  - Uses 'media' as uploadsCollection for meta images
  - tabbedUI: true for better admin experience
- Redirects plugin configuration:
  - Applied to 'pages' and 'posts' for redirect targets
  - Creates auto-generated Redirects collection
  - Customized labels and admin group placement
- Nested Docs plugin configuration:
  - Applied to 'categories' collection for hierarchical structure
  - Uses existing 'parent' and 'breadcrumbs' fields from Categories collection
  - generateLabel and generateURL functions for breadcrumb display
- IMPORTANT: SEO plugin adds 'meta' fields automatically - must remove existing 'meta' groups from Pages/Posts to avoid duplicate field errors
- Used a generic SeoDocument interface instead of importing from payload-types.ts (which is auto-generated and may not exist during builds)
- Build succeeds without database - Postgres connection errors during static generation are handled gracefully by try/catch
- All acceptance criteria met:
  - ✓ @payloadcms/plugin-seo installed and configured
  - ✓ @payloadcms/plugin-redirects installed and configured
  - ✓ @payloadcms/plugin-nested-docs installed and configured
  - ✓ src/plugins/index.ts exports plugins array
  - ✓ Plugins registered in payload.config.ts
  - ✓ SEO fields added to Pages and Posts collections (via plugin)

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm build: SUCCESS (Postgres errors handled gracefully)

Gotchas for future stories:
- Don't import from payload-types.ts in plugin config - file is auto-generated and may not exist
- SEO plugin adds meta.title, meta.description, meta.image - remove duplicate fields from collections
- Plugins are registered via the 'plugins' array in buildConfig
- Nested Docs plugin expects parentFieldSlug and breadcrumbsFieldSlug to match existing field names
- The Redirects collection is auto-created by the plugin - no need to define manually

=== Iteration 27 - S27 - 2026-02-02 20:58:00 ===
Status: COMPLETE
Learnings:
- Created .env.example with DATABASE_URL, PAYLOAD_SECRET, NEXT_PUBLIC_SERVER_URL, NEXT_PUBLIC_APP_NAME
- Updated src/lib/env.ts with Zod validation schema for all environment variables
  - Server-side: DATABASE_URL, PAYLOAD_SECRET, VERCEL_PROJECT_PRODUCTION_URL (all optional for builds)
  - Client-side: NEXT_PUBLIC_APP_NAME (with default), NEXT_PUBLIC_SERVER_URL
- Added TypeScript declarations in src/env.d.ts extending NodeJS.ProcessEnv interface
- Updated vercel.json with:
  - $schema for IDE support
  - CORS headers for /api/* routes (needed for Payload CMS REST API)
  - Default NEXT_PUBLIC_APP_NAME env var
- Updated .gitignore to properly track .env.example while excluding actual .env files
  - Changed from `.env*` to specific files (.env, .env.local, etc.)
  - Added `!.env.example` to force tracking
- CRITICAL FIX: vitest.config.ts had incorrect path alias
  - Was: "@": path.resolve(__dirname, "./") (root directory)
  - Fixed: "@": path.resolve(__dirname, "./src") (matches tsconfig.json)
  - Also added @payload-config alias for consistency
- Updated page.test.tsx to work with new async Server Component
  - Old tests referenced static Jigjoy template content that no longer exists
  - New tests mock Payload utilities and test fallback content behavior
  - Used vi.mock() for @/utilities, @/components/Hero, @/blocks/RenderBlocks
  - Async Server Components need `await Component()` before render()

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (15 tests in 3 files)
- pnpm build: SUCCESS (Postgres errors handled gracefully)

Acceptance Criteria Met:
- ✓ .env.example with DATABASE_URL, PAYLOAD_SECRET, NEXT_PUBLIC_SERVER_URL
- ✓ src/lib/env.ts for environment validation (using Zod)
- ✓ TypeScript declarations for environment variables (src/env.d.ts)
- ✓ vercel.json updated for deployment
- ✓ .gitignore includes .env (and excludes .env.example)

Gotchas for future stories:
- Vitest path aliases must match tsconfig.json paths exactly
- When testing async Server Components, await the component function first
- Environment variables should be optional during builds for CI/CD compatibility
- Zod's .url() validator rejects empty strings - use .optional() for optional URLs
- VERCEL_PROJECT_PRODUCTION_URL doesn't include protocol - add https:// when using
- S29 (Update Tests) should add more comprehensive tests for Payload components

=== Iteration 28 - S28 - 2026-02-02 21:03:00 ===
Status: COMPLETE
Learnings:
- Created src/seed/index.ts - comprehensive idempotent seed script for Payload CMS
- Uses Payload Local API via `getPayload({ config })` from 'payload'
- Seeds in order: admin user → categories → pages → posts → Header → Footer → SiteSettings
- Idempotency achieved by checking for existing data before creating:
  - Users: check by email
  - Categories/Pages/Posts: check by slug
  - Globals: check if already configured (has navItems, columns, or custom siteName)
- IMPORTANT: PostgreSQL uses numeric IDs (number type), not string IDs
  - Changed adminUserId and categoryIds from string to number types
  - Removed String() conversion, use IDs directly
- Lexical rich text format requires specific structure:
  - Must have root.type, root.format, root.indent, root.version, root.direction, root.children
  - Children must have type, version, and additional type-specific fields
  - Created RichTextContent interface matching Payload's expected type
- Content block 'columns' field uses '1', '2', '3' values (not 'one', 'two', 'three')
- Globals use findGlobal/updateGlobal methods (not find/create like collections)
- Script exits with process.exit(0) on success, process.exit(1) on failure
- Removed .gitkeep from src/seed/ since we now have real content
- The payload-types.ts file is auto-generated and was committed as part of this story

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (15 tests in 3 files)
- pnpm build: SUCCESS (Postgres errors handled gracefully with fallback content)

Acceptance Criteria Met:
- ✓ src/seed/index.ts main seed script
- ✓ Seeds admin user (admin@example.com)
- ✓ Seeds sample pages (Home, About)
- ✓ Seeds sample posts (3 posts)
- ✓ Seeds sample categories (Technology, Design, Business)
- ✓ Seeds Header, Footer, SiteSettings globals
- ✓ Idempotent - can run multiple times safely
- ✓ Uses Payload Local API
- ✓ Runnable via pnpm seed (script already existed in package.json from S1)

Gotchas for future stories:
- Payload with PostgreSQL uses numeric IDs, not string IDs
- Rich text content must follow Lexical's exact structure - use typed interfaces
- Global slugs are kebab-case in Payload: 'site-settings' not 'siteSettings'
- Seed script requires a running database - won't work during static builds
- To run seed: start PostgreSQL, set DATABASE_URL, then run pnpm seed
- Admin credentials: admin@example.com / admin123 (change in production!)
- S29 (Update Tests) is next

=== Iteration 29 - S29 - 2026-02-02T20:11:15Z ===
Status: COMPLETE
Learnings:
- Created comprehensive test suites for Payload integration components
- Test files created:
  - src/utilities/formatDateTime.test.ts (21 tests) - date formatting and relative time
  - src/utilities/getURL.test.ts (7 tests) - server/client URL resolution
  - src/utilities/mergeOpenGraph.test.ts (10 tests) - OpenGraph metadata merging
  - src/blocks/Content/Component.test.tsx (16 tests) - rich text block rendering
  - src/blocks/MediaBlock/Component.test.tsx (15 tests) - image block with positioning
  - src/blocks/CallToAction/Component.test.tsx (19 tests) - CTA with buttons and backgrounds
  - src/blocks/RenderBlocks.test.tsx (14 tests) - dynamic block rendering
- Total tests: 117 (increased from 15 to 117)
- Key testing patterns:
  - Mock Lexical rich text content with proper structure (root.children with type, version, text)
  - Use vi.useFakeTimers() for time-dependent tests (formatRelativeTime)
  - Handle Next.js Metadata type complexity with helper functions for type property access
  - Test both populated (object) and unpopulated (string ID) media states
  - NODE_ENV is 'test' in vitest, so development-only console.warn won't fire
- TypeScript gotcha: Metadata['openGraph'] from Next.js is a union type, 'type' property doesn't exist on all variants
  - Solution: Use helper function with type assertion to safely access 'type'

Test Results:
- pnpm lint: SUCCESS
- pnpm typecheck: SUCCESS
- pnpm test: SUCCESS (117 tests in 10 files)
- pnpm build: SUCCESS (Postgres errors handled gracefully with fallback content)

Acceptance Criteria Met:
- ✓ Existing tests still pass with new structure (original 15 tests still pass)
- ✓ Tests for utility functions (formatDateTime, getURL, mergeOpenGraph)
- ✓ Tests for block components (Content, MediaBlock, CallToAction)
- ✓ Tests for RenderBlocks component
- ✓ Mock Payload data in tests where needed
- ✓ All tests pass: pnpm test (117 tests)

Gotchas for future stories:
- When testing async Server Components, await the component first: `await Component()`
- Lexical rich text mock structure must include type, version, children at each level
- OpenGraph type checking requires helper functions due to Next.js union types
- vitest.config.ts path aliases must match tsconfig.json exactly
- S30 (Update Documentation) is next
